Настройка этапов документа
==============================
Валидаторы позволяют применять логику в проверках доступа к полям, проверках этапа и в переходах.
Блок валидатора представляет из себя список условий, выполнение которых небходимо для применения родительского блока, который содержит валидатор.

.. note::
    С точки зрания логики условия в валидаторе объединены оператором И

Для тега валидатора обязательным свойством является ``rule`` . Оно определяет правило по которому будет проведена проверка.

Правила валидации:

*   **Валидатор соответствия**

    ``rule = "equal"`` или ``rule = "not_equal"``. Проверяет поле или свойство документа на равенство/неравенство заданному значению:

    .. code-block:: xml

        <validator>
          <field1 rule="equal">120</field1>
          <field2 rule="not_equal">200</field2>
        </validator>

    Валидация пройдет при условии что поле *field1* **равно 120**, а поле *field2* **не равно 200**.

*   **Валидатор "необходимо к заполнению"**

    ``rule = "required"``

    Данное правило применимо **только к валидации** этапа или перехода. Проверяет поле документа на заполненность:

    .. code-block:: xml

        <validator>
            <field3 rule="requred"/>
        </validator>

    В примере блок валидации будет применен только в случае наличия данных в поле документа field3.

*   **Вызов функции валидации**

    ``rule = call``

    В системе "Сфера" существуют и более сложные проверки, которые могут принимать один или несколько аргументов. В функцию валидации можно передавать значение полей через свойство ``arguments``, при этом в утилитах ядра *вызывается* функция с заданными параметрами

    .. code-block:: xml

        <validator>
            <has_role rule="call" arguments="admin">True</has_role>
        </validator>

    В данном примере валидатор проверяет наличие роли "admin" у оператора системы, который работает с документом.

    *Функции проверки, существующие в ядре:*

    *   **has_role(name)** - Проверяет наличие ролей доступа в ролях оператора. **name:** Строка с названиями ролей, разделенных запятой (или одной ролью);

    *   **has_all_roles(name)** - Проверяет пересечение *всех* запрошенных ролей с имеющимися. **name:** Строка с названиями ролей, разделенных запятой (или одной ролью);

    *   **has_file(name)** - Валидатор проверки наличия хотя бы одного типа файла.  **name:** Список типов файлов, разделенный запятой;

    *   **has_all_files** - Валидатор проверки наличия всех типов файлов. **name:** Список типов файлов, разделенный запятой;

    *   **has_any_open_task** - Проверка наличия открытых типов задач. **name:** Список типов задач, разделенный запятой;

    *   **has_any_closed_task** - Проверка наличия закрытых типов задач. **name:** Список типов задач, разделенный запятой.


Вы можете писать собственные проверки на языке *python*. Для этого необходимо перегрузить класс **DocumentValidatorMixin**:

Создайте файл **validators.py** в директории ``/<ИМЯ_ПРОЕКТА>/document/``

В файле **validators.py** создайте класс **DocumentValidatorMixin**.

Не забудьте подключить новый класс в основной фаил проекта **__init.py__**:

.. code-block:: python

    from .validator import DocumentValidatorMixin

    class DocumentMixin(..., DocumentValidatorMixin,)

Пример **validators.py**:

.. code-block:: python

    from datetime import date

    class DocumentValidatorMixin(object):

        @property
        def is_date_in_future(self, date):
            if date > date.today():
                return  True
        return False

В примере объявляется функция **is_date_in_future**, которая принимает на вход аргумент **date**. Функция возвращает *True* если переданная дата больше текущей даты (в будущем), иначе возвращает *False*.

Пример использования в конфигурационном файле этапа:

.. code-block:: xml

    <validator>
        <is_date_in_future rule="call" arguments="date_plan">True</is_date_in_future>
    </validator>

Если значение поля **date_plan** является датой в будущем блок валидации пройдет проверку.
